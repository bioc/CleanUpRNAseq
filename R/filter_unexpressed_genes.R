#' Determine genes which are spliced, but not supported by junction reads
#'
#' If genes are spliced, but not supported by junction reads, they are
#' considered as not expressed and the other reads are likely due to DNA
#' contamination. This function should be used with great caution because some
#' libraries might have poor representation of junction reads. Please visualize
#' the BAM files in a genome browser, like IGV first, to get a sense of the
#' data.
#'
#' @param ensdb_sqlite An [ensembldb::EnsDb-class] object or a character(1),
#'   specifying a path to an SQLite database  for an [ensembldb::EnsDb-class]
#'   object.
#' @param junction_counts  A data frame or matrix containing junction counts for
#'   all samples of interest generated by [Rsubread::featureCounts()] with a GTF
#'   file as annotation.
#' @param min_junction_counts An integer(1), minimal number of junction read
#'   counts needed to consider a multi-exonic gene is expressed.
#' @param min_samples An integer(1), minimal number of samples needed to
#'   consider a multi-exonic gene of `min_junction_counts` is expressed.
#'
#' @return A character vector of IDs of multi-exonic genes which are not
#'   supported by a minimal number of junction reads in minimal number of
#'   samples.
#' @export
#' @importFrom ensembldb EnsDb exons
#' @importFrom utils read.delim
#' @examplesIf interactive()
#' op <- options(timeout = max(3000, getOption("timeout")))
#' cache_env <- getOption("cache_env")
#' if (!exists("tmp_dir", envir = cache_env)) {
#'     tmp_dir <- tempdir()
#' }
#' tmp_dir <- cache_env$tmp_dir
#' if (!exists("counts_summary", envir = cache_env)) {
#'     count_url <- paste0(
#'         "https://zenodo.org/records/11458839/files/",
#'         "read_count_summary.RData?download=1"
#'     )
#'     retry_download({download.file(
#'         url = count_url,
#'         destfile = file.path(tmp_dir, "read_count_summary.RData"),
#'         mode = "wb"
#'     )})
#'     load(file.path(tmp_dir, "read_count_summary.RData"))
#'     cache_env$counts_summary <- counts_summary
#' }
#'
#' # download the EnsDb SQLite database
#' if (!exists("hs_ensdb_sqlite", envir = cache_env)) {
#'     ensdb_url <- paste0(
#'         "https://zenodo.org/records/11458839/files/",
#'         "GRCh38.V110.ensdb.sqlite.zip?download=1"
#'     )
#'     retry_download({download.file(
#'         url = ensdb_url,
#'         destfile = file.path(tmp_dir, "GRCh38.V110.ensdb.sqlite.zip"),
#'         mode = "wb"
#'     )})
#'     unzip(file.path(tmp_dir, "GRCh38.V110.ensdb.sqlite.zip"),
#'         exdir = tmp_dir
#'     )
#'     hs_ensdb_sqlite <- file.path(tmp_dir, "GRCh38.V110.ensdb.sqlite")
#'     cache_env$hs_ensdb_sqlite <- hs_ensdb_sqlite
#' }
#'
#' unexpressed_spliced_genes <-
#'     get_unexpressed_spliced_genes(
#'         ensdb_sqlite = cache_env$hs_ensdb_sqlite,
#'         junction_counts =
#'             cache_env$counts_summary$gtf$counts_junction,
#'         min_junction_counts = 1,
#'         min_samples = 1
#'     )
#'

get_unexpressed_spliced_genes <- function(ensdb_sqlite = NULL,
                                          junction_counts = NULL,
                                          min_junction_counts = 1,
                                          min_samples = 1) {
    if (!is(ensdb_sqlite, "EnsDb") && !is.character(ensdb_sqlite)) {
        stop("Please provide a single EnsDb object or a EnsDb SQLite",
             " database file!")
    } else if (is.character(ensdb_sqlite)) {
        if (file.exists(ensdb_sqlite)) {
            ensdb <- EnsDb(ensdb_sqlite)
        } else {
            stop("ensdb_sqlite is a non-existing SQLite database file")
        }
    } else {
        ensdb <- ensdb_sqlite
    }

    if (!is.data.frame(junction_counts) &&
        !is.matrix(junction_counts)) {
        stop("junction_count must be a data frame or a matrix!")
    }
    if (min_junction_counts < 1 || min_samples < 1) {
        stop(
            "min_junction_counts and min_samples must be greater than ",
            "or equal to 1."
        )
    }

    exon_GR <-
        exons(ensdb, columns = c("exon_id", "tx_id", "gene_id"))
    tx_exon_num <- as.data.frame(table(exon_GR$tx_id))
    colnames(tx_exon_num) <- c("tx_id", "exon_num")
    tx_exon_num <- merge(
        unique(data.frame(
            tx_id = exon_GR$tx_id,
            gene_id = exon_GR$gene_id
        )),
        tx_exon_num,
        by = "tx_id",
        sort = FALSE
    )

    ## annotated genes with more than 1 exons in the GTF file
    annotated_spliced_genes <-
        unique(tx_exon_num$gene_id[tx_exon_num$exon_num > 1])

    junction_counts <- junction_counts[!is.na(junction_counts[, 1]), ]
    is_valid_junction <-
        apply(
            junction_counts[, 9:ncol(junction_counts)], 1,
            function(.x) {
                sum(.x >= min_junction_counts) >= min_samples
            }
        )
    junction_counts <-
        junction_counts[is_valid_junction, ]
    secondary_genes <- junction_counts[, 2]
    secondary_genes <- secondary_genes[!is.na(secondary_genes)]
    secondary_genes <-
        unique(unlist(strsplit(secondary_genes, split = ",")))
    expressed_spliced_genes <-
        unique(c(junction_counts[, 1], secondary_genes))
    unexpressed_spliced_genes <-
        as.character(annotated_spliced_genes[!annotated_spliced_genes %in%
            expressed_spliced_genes])

    unexpressed_spliced_genes
}

#' Filter out unexpressed genes
#'
#' Filter out unexpressed genes from the count table
#'
#' @param counts A numeric matrix or data frame containing gene expression count
#'   data for an RNA-seq experiment, with row names for gene ID and column names
#'   for sample names. If values are not integers, it will be rounded. This
#'   count table can be DNA contamination corrected or not.
#' @param salmon_res An output of [salmon_res()].
#' @param unexpressed_spliced_genes A character(n), IDs of spliced genes without
#'   enough support of junction reads. An output of
#'   [get_unexpressed_spliced_genes()] function.
#' @param metadata A data frame file with column names: sample_name,
#'   is_contaminated, and group. The *is_contaminated* column specifies whether
#'   the sample is DNA-contaminated, TRUE/FALSE, based on the various
#'   exploratory analyses using this package. The *sample_name* and *group*
#'   columns contain the unique sample labels, and the experimental conditions
#'   for each sample. The order of the three columns doesn't matter, but the
#'   order of the sample name in the rows must match those in the count table
#'   specified by `counts`.
#' @param filter_by_clean_samples A logical(1), indicating whether filtering is
#'   based on samples without genomic DNA contamination.
#' @param min_tpm A numeric(1), minimal TPM cutoff threshold.
#' @param min_counts A numeric(1), minimal count cutoff threshold. Default is
#'   10.
#' @param min_samples An integer(1), minimal number of samples with TPM above
#'   min_tpm.
#'
#' @importFrom edgeR cpm
#'
#' @return An integer-valued matrix containing gene expression count data for an
#'   RNA-seq experiment, with row names for gene ID and column names for sample
#'   names. Rows corresponding to multi-exonic genes without enough support of
#'   junction reads, or expression level lower than minimal CPM in more than
#'   minimal number of samples are filtered out.
#' @export
#' @examplesIf interactive()
#' op <- options(timeout = max(3000, getOption("timeout")))
#' cache_env <- getOption("cache_env")
#' if (!exists("tmp_dir", envir = cache_env)) {
#'     tmp_dir <- tempdir()
#' }
#' tmp_dir <- cache_env$tmp_dir
#'
#' if (!exists("counts_summary", envir = cache_env)) {
#'     count_url <- paste0(
#'         "https://zenodo.org/records/11458839/files/",
#'         "read_count_summary.RData?download=1"
#'     )
#'     retry_download({download.file(
#'         url = count_url,
#'         destfile = file.path(tmp_dir, "read_count_summary.RData"),
#'         mode = "wb"
#'     )})
#'     load(file.path(tmp_dir, "read_count_summary.RData"))
#'     cache_env$counts_summary <- counts_summary
#' }
#'
#' # download the EnsDb SQLite database
#' if (!exists("hs_ensdb_sqlite", envir = cache_env)) {
#'     ensdb_url <- paste0(
#'         "https://zenodo.org/records/11458839/files/",
#'         "GRCh38.V110.ensdb.sqlite.zip?download=1"
#'     )
#'     retry_download({download.file(
#'         url = ensdb_url,
#'         destfile = file.path(tmp_dir, "GRCh38.V110.ensdb.sqlite.zip"),
#'         mode = "wb"
#'     )})
#'     unzip(file.path(tmp_dir, "GRCh38.V110.ensdb.sqlite.zip"),
#'         exdir = tmp_dir
#'     )
#'     hs_ensdb_sqlite <- file.path(tmp_dir, "GRCh38.V110.ensdb.sqlite")
#'     cache_env$hs_ensdb_sqlite <- hs_ensdb_sqlite
#' }
#' unexpressed_spliced_genes <-
#'     get_unexpressed_spliced_genes(
#'         ensdb_sqlite = cache_env$hs_ensdb_sqlite,
#'         junction_counts =
#'             cache_env$counts_summary$gtf$counts_junction,
#'         min_junction_counts = 1,
#'         min_samples = 1
#'     )
#'
#' # download the Salmon quantification results
#' if (!exists("salmon_quant", envir = cache_env)) {
#'     salmon_url <-
#'         paste0("https://zenodo.org/records/11458839/files/",
#'         "salmon_quant_summary.RData?download=1")
#'     destfile <- file.path(tmp_dir, "salmon_quant_summary.RData")
#'     retry_download({download.file(
#'         url = salmon_url,
#'         destfile = destfile,
#'         mode = "wb"
#'     )})
#'
#'     ## load the salmon_quant object
#'     load(destfile)
#'     cache_env$salmon_quant <- salmon_quant
#' }
#' ## global correction
#' corrected_counts <- global_correction(
#'     intergenic_featureCounts_res =
#'         cache_env$counts_summary$intergenic_region,
#'     salmon_res = cache_env$salmon_quant
#' )
#' metadata <- cache_env$counts_summary$metadata
#' contaminated_sample <- c("CD1A(-)_m2_1", "CD1A(-)_m3_1")
#' metadata$is_contaminated <- ifelse(metadata$sample_name %in%
#'     contaminated_sample, "TRUE", FALSE)
#' filtered_corrected_counts <-
#'     filter_unexpressed_genes(
#'         counts = corrected_counts,
#'         salmon_res = cache_env$salmon_quant,
#'         unexpressed_spliced_genes = unexpressed_spliced_genes,
#'         metadata = metadata,
#'         min_tpm = 1,
#'         min_samples = 1
#'     )
#' options(op)

filter_unexpressed_genes <-
    function(counts = NULL,
             salmon_res = NULL,
             unexpressed_spliced_genes = NULL,
             metadata = data.frame(
                 sample_name = vector(mode = "character"),
                 is_contaminated = vector(mode = "logical"),
                 group = vector(mode = "character")
             ),
             filter_by_clean_samples = TRUE,
             min_samples = 1,
             min_counts = 10,
             min_tpm = 1) {
        if (!is.matrix(counts) && !is.data.frame(counts)) {
            stop("A count table must be provied as a matrix or data frame.")
        }
        if (is.data.frame(counts)) {
            counts <- as.matrix(counts)
        }
        if (!is.numeric(counts)) {
            stop("The count table must be numeric")
        }

        if (!is.data.frame(metadata)) {
            stop("metadata should be a data frame.")
        } else if (any(is.na(metadata)) ||
            any(metadata == "") || any(metadata == " ")) {
            stop("Missing value(s) found in the metadata.")
        }
        if (any(!c("sample_name", "is_contaminated", "group") %in%
                colnames(metadata))) {
            stop(
                "Not all column names: sample_name, BAM_file, ",
                "group are included in the metadata."
            )
        }
        sample_name <- metadata$sample_name
        if (any(duplicated(sample_name))) {
            stop("Some sample names are not unique in the metadata.")
        }

        ## remove all-zeros genes from count table
        counts <- counts[rowSums(counts) != 0, ]

        if (!all(sort(colnames(counts)) ==
                 sort(as.character(metadata$sample_name)))) {
            stop(
                "The column names of the raw count matrix DO NOT match the ",
                "sample names in the metadata!"
            )
        } else {
            counts <- counts[, metadata$sample_name]
        }
        ## remove unexpressed multi-exonic genes
        if (!is.null(unexpressed_spliced_genes)) {
            counts <- counts[!rownames(counts) %in%
                                 unexpressed_spliced_genes, ]
        }

        ## filter by TPM
        unexpressed_genes <-
            rownames(salmon_res$abundance)[rowSums(salmon_res$abundance >=
                                                       min_tpm) ==
                ncol(salmon_res$abundance)]
        counts <- counts[!rownames(counts) %in% unexpressed_genes, ]
        # check if uncontaminated samples exist in each distinct group. If so,
        # filter the count matrix by number of samples with expression above
        # min_cpm
        uncontaminated_samples <-
            metadata$sample_name[metadata$is_contaminated == FALSE]

        # Test if each group has some uncontaminated samples
        uncontaminated_per_group <-
            length(unique(metadata$group[
                metadata$is_contaminated == FALSE])) ==
            length(unique(metadata$group))
        if (uncontaminated_per_group) {
            ## filter by uncontaminated samples by min_counts
            uncontaminated_counts <- counts[, uncontaminated_samples]
            uncontaminated_metadata <-
                metadata[uncontaminated_samples %in%
                    metadata$sample_name, ]

            keep <- rowSums(uncontaminated_counts >= min_counts) ==
                ncol(uncontaminated_counts)

            counts <- counts[keep, ]

            ## filter by uncontaminated samples by min_tpm
            uncontaminated_abundance <-
                salmon_res$abundance[, uncontaminated_samples]
            unexpressed_genes <-
                rownames(uncontaminated_abundance)[
                    rowSums(uncontaminated_abundance >= min_tpm) ==
                    ncol(uncontaminated_abundance)]
            counts <- counts[!rownames(counts) %in% unexpressed_genes, ]
        } else {
            # all samples are contaminated or samples in one group are all
            # contaminated! This operation might remove a small number of genes,
            # which only express the mono-exonic isoforms, though they can
            # express multi-exonic isoforms under other conditions (based on
            # the GTF).

            keep <-
                rowSums(counts >= min_counts) >= min(table(metadata$group))
            counts <- counts[keep, ]

            # remove genes not expressed by min_counts and min_tpm in clean
            # samples. this operation (filter based on clean samples only from
            # a single condition) might remove some genes only expressed in
            # contaminated samples (false negatives).
            if (filter_by_clean_samples) {
                ## filter by uncontaminated samples by min_counts
                uncontaminated_counts <- counts[, uncontaminated_samples]
                uncontaminated_metadata <-
                    metadata[uncontaminated_samples %in%
                        metadata$sample_name, ]

                keep <- rowSums(uncontaminated_counts >= min_counts) ==
                    ncol(uncontaminated_counts)
                counts <- counts[keep, ]

                ## filter by uncontaminated samples by min_tpm
                uncontaminated_abundance <-
                    salmon_res$abundance[, uncontaminated_samples]
                unexpressed_genes <-
                    rownames(uncontaminated_abundance)[
                        rowSums(uncontaminated_abundance >= min_tpm) ==
                        ncol(uncontaminated_abundance)]
                counts <- counts[!rownames(counts) %in% unexpressed_genes, ]
            }
        }
        counts
    }
